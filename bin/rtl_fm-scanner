#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use DBIx::Connector;

use constant NO_PASS     => 0;
use constant MANUAL_PASS => 1;
use constant AUTO_PASS   => 2;

my $config = plugin Config => { file => '../config/scanner.conf' };

app->plugin('RenderFile');
app->plugin('CORS'); # lets the client get around same origin policy restriction

app->secrets( ['Specfying a secret to make the reminder go away.'] );

my $dbname = '../data/freqs.db';

my $xmit_timer;      # stores the id of the loop that limits length of xmit
my $state = {};
#app->defaults( state => () );

get '/self' => sub {
    my $c = shift;

    $c->render( json => { function => 'Scanner' } );
# ugh this is nasty but I need to store it here because it does not work in the helper
    app->defaults->{audio_url} = $c->url_for('audio')->to_abs;
};

get '/script' => { template => 'script' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath'            => "../archive/$file",
        'content_disposition' => 'inline'
    );
};

get '/freqs' => sub {
    my $c = shift;

    $c->render( json => app->defaults('freq_list') );
};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    my $client =
      $c->tx->remote_address . $c->tx->remote_port;    # unique identifier

    $c->send( { json => app->config_msg } );

    my $id        = Mojo::IOLoop->recurring(
        0.5 => sub {
            my $loop = shift;

	    while ( my $msg = app->get_msg($client) )
            {
                $c = $c->send( { json => $msg } );
                app->log->info("item to let client know about: $msg->{type}");
            }
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

	    if ( $hash->{type} eq 'ping' ) {
		app->log->debug('client pinged me');
            } elsif ( $hash->{type} eq 'set_pass' ) {
                app->update_pass( $hash->{freq}, $hash->{bank}, $hash->{pass} );
                $c->start_rtlfm;
            }
            elsif ( $hash->{type} eq 'set_squelch' ) {
                $config->{squelch} = $hash->{squelch};
                $c->start_rtlfm;    # need to start rtl_fm for changes to take effect

		app->publish( app->config_msg );
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed with status $code.");
        }
    );
};

helper get_msg => sub {
    my ( $self, $client ) = @_;

    return shift @{ app->defaults->{announce_sub}{$client} };
};

helper publish => sub {
    my ( $self, $msg ) = @_;

    push @$_, $msg
      for values %{ app->defaults->{announce_sub} };
};

helper config_msg => sub {
    my $self = shift;

    return { type => 'config', %{ $config } };
};


helper connector => sub {
    state $db = DBIx::Connector->new( "dbi:SQLite:$dbname", "", "" )
      or app->log->error('Could not connect to database');
};

helper db => sub { shift->connector->dbh };

helper select => sub {
    my ( $self, $group ) = @_;

    # TODO:  At some point limit based on current year or something.
    # TODO:  Sort by designator
    my $sth =
      eval { $self->db->prepare(
          'select * from freqs where bank like ? order by label'); }
      || return undef;
    $sth->execute($group);
    return $sth->fetchall_arrayref({});
};

helper update_pass => sub {
    my ( $self, $freq, $bank, $pass ) = @_;

    app->log->info(
        sprintf( 'change pass for %s to %s', $freq, $pass ) );


    my $sth = eval {
        $self->db->prepare(
            'UPDATE freqs SET pass=? WHERE freq = ? AND bank = ?');
    }
      || return undef;
    $sth->execute( $pass, $freq, $bank );

    app->load_freqs;
    app->publish( { type => 'update' } ); # what freqs are available
    #app->log->info( sprintf('|%s|%s|%s|', $pass, $freq, $label) );
};

helper update_count => sub {
    my ( $self, $entry ) = @_;
    my $sth = eval {
        $self->db->prepare(
            'UPDATE freqs SET count=? WHERE freq = ? AND bank = ?');
    }
      || return undef;
    $sth->execute( $entry->{count}, $entry->{freq}, $entry->{bank} );
};


helper set_state => sub {
    my ( $c, $status, $freq, $file ) = @_;

    #my $entry;
    if ( $status eq 'OPEN' ) {
        my @freq_list  = @{ app->defaults('freq_list') };
	(my $entry) = grep { $_->{freq} == $freq } @freq_list;
	$state->{$file} = $entry;
	$state->{$file}->{type} = 'audio';
	$state->{$file}->{file} = $file;
        $state->{$file}->{url}  = app->defaults->{audio_url};
        $state->{$file}->{start} = time();
        $state->{$file}->{end} = 'none yet';

        #app->defaults( state => $entry );
        #app->log->debug( app->dumper($detail) );

        # start timer to stop open mic/long data
        $xmit_timer = Mojo::IOLoop->timer(
            10 => sub {
                my $loop = shift;
                app->update_pass( $freq, $state->{$file}->{bank}, AUTO_PASS );
	        app->publish( $state->{$file} );  # for testing let client know
		delete $state->{$file};
                $c->start_rtlfm;
            }
        );
    }
    else {
        Mojo::IOLoop->remove($xmit_timer);
        $state->{$file}->{end} = time();
	my $count = $state->{$file}->{count};
	$state->{$file}->{count} = ++$count;
	app->update_count($state->{$file});
	app->publish( $state->{$file} );
        delete $state->{$file};
    }

};

helper load_freqs => sub {

    my @freqs;
    foreach my $bank ( @{ $config->{banks} } ) {
        push @freqs,  @{ app->select( $bank ) };
    }

    app->defaults( freq_list => \@freqs );
};

helper start_rtlfm => sub {
    my $c = shift;

    # errors to handle:
    # dongle yanked:
    #    rtlsdr_demod_write_reg failed with -1
    #    rtlsdr_demod_read_reg failed with -4
    #    cb transfer status: 5, canceling

    if ( defined app->defaults('rtlfm_pid') ) {
        my $pid = app->defaults('rtlfm_pid');
        app->log->info( sprintf( 'About to kill rtl_fm (pid: %s)', $pid ) );
        kill 'HUP', $pid;
        delete app->defaults->{rtlfm_pid};
        Mojo::IOLoop->timer( 1 => sub { $c->start_rtlfm } );    # Time to exit
        return;
    }

    app->log->info('about to start rtl_fm');

    my @freqs = @{ app->defaults->{freq_list} };
    my @freq_args;
    foreach my $entry ( @freqs ) {

	if ($entry->{pass} == NO_PASS ) {
             push @freq_args, sprintf( "-f %sM", $entry->{freq} );
        }

    }

    #app->log->info('freqs'.dumper(@freq_args));
    #app->log->debug(dumper(app->defaults->{freq_list}));

    my @args = ( '/usr/local/bin/rtl_fm',
		 '-M', $config->{mode},
		 '-p', $config->{ppm},
		 '-s', '12k',
		 '-l', $config->{squelch},
		 '-g', $config->{gain},
		 '-E', 'wav',
		 @freq_args,
		 '-n', '../archive',
		 '/tmp/ignored.out'
	);
    my $cmd = join(' ', @args);

    my $rtlfm_fifo;
    my $rtlfm_pid = open( $rtlfm_fifo, "$cmd 2>&1 |" ) or do {

     # this will not be hit if rtl_fm command is executed and there is no dongle
        app->log->error("Couldn't open rtl_fm: $!");
        return;
    };

    my $stream_in = Mojo::IOLoop::Stream->new($rtlfm_fifo);

    $stream_in = $stream_in->timeout(0);
    $stream_in->on(
        read => sub {
            my ( $stream_in, $bytes ) = @_;
            chomp($bytes);

            # I probably need to seperate OPEN from CLOSED
            if ( $bytes =~ /(OPEN|CLOSED)\|(\d+)\|(.+)/ ) {
                my $status   = $1;
                my $cur_freq = $2 / 1000000;
                my $file     = $3;
                app->set_state( $status, $cur_freq, $file );
                app->log->info(
                    sprintf(
                        'status: %s freq: %s file: %s',
                        $status, $cur_freq, $file
                    )
                );
            }
            elsif ( $bytes =~ /No supported devices found/ ) {
                app->log->error('No dongle connected!');

                # retry in a few seconds
                Mojo::IOLoop->timer( 6 => sub { $c->start_rtlfm } );
                return;
            }
            elsif ( $bytes =~ /Using device/ )
            {    # set pid here as rtl_fm can "open" and fail soon after
                app->defaults( rtlfm_pid => $rtlfm_pid );
            }
            else {
                app->log->info(
                    sprintf( 'not sure what this is: %s', $bytes ) );
            }
        }
    );
    $stream_in->on(
        close => sub {
            my $stream_in = shift;
            app->log->info('stream_in closed');
        }
    );
    $stream_in->on(
        error => sub {
            my ( $stream_in, $err ) = @_;
            app->log->info('stream_in error');
        }
    );
    my $sid = Mojo::IOLoop->stream($stream_in);
    $stream_in->on( finish => sub { Mojo::IOLoop->remove($sid) } );

};

app->load_freqs;

app->start_rtlfm;

app->start;

__DATA__

@@ script.html.ep
console.log("Scanner code running");

var scan_ws = new WebSocket('<%= url_for('output')->to_abs %>');

setInterval(function () {
        scan_ws.send(JSON.stringify( { type: "ping" } ));
        }, 45000
);

var scan_config;
scan_ws.onmessage = function (event) {
    var msg = $.parseJSON(event.data);

    switch (msg.type) {
        case 'audio':
            enqueue(msg);
            scanner_page();
            break;
        case 'update':
            scanner_page();
            break;
        case 'config':
            scan_config = msg;
            break;
    }
};

scanner_page = function () {

    // TODO: this is pretty convoluted and better way should be found
    var active_id = $("#switcher").tabs("option", "active");
    active = $("#switcher ul>li a").eq(active_id).attr('href');

    if (active != '#scanner') { return }

    console.log("Populating scanner page");

    $.getJSON( '<%= url_for('freqs')->to_abs %>' )
        .done(function( json ) {
   	    $('#scanner').empty().append('<ul data-role="listview" id="frequencies"></ol>');
	    $.each( json, function(i, detail) {

                var info = detail.freq.toString();
                if (detail.count) { info += ' / ' + detail.count + ' hits' }
                switch (detail.pass) {
                    case 1:
                        info += ' / Manual Pass';
                        break;
                    case 2:
                        info += ' / Auto Pass';
                        break;
                }
                var contents = '<h2>' + detail.label + '</h2><p>' + 
                               info + '</p>';

		$('<li/>')
		    .append(
		  	$('<a/>', {
			    html: contents,
			    href: "#" + detail.freq,
                            id: detail.freq + '-' + detail.bank
			})
			).appendTo("#frequencies");

            });  // end .each

            // There may be another way but this appears to work:
            // http://www.gajotres.net/uncaught-error-cannot-call-methods-on-prior-to-initialization-attempted-to-call-method-refresh/
            $('#frequencies').listview().listview('refresh');

            $( '#frequencies li a' ).on( "taphold", function( event ) {
                var id = $( this ).attr('id');

                var entry = $.grep(json, function(obj) {
                    return id == obj.freq + '-' + obj.bank;
                });

                frequency_config(entry[0]);
            });

        });  // end .done


};

frequency_config = function(entry) {

    var choices = [ 'none', 'manual', 'auto' ];

    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : entry.label + ' (' + entry.freq + ')'
    }).appendTo($config);

    //create a form for the pop up
    var $form = $('<form/>');

    var $radio_btns = $('<fieldset/>', {
            'data-role': 'controlgroup',
            'data-type': 'horizontal'
        });

    $('<legend/>', { text: 'Pass' }).appendTo($radio_btns);

    $.each( choices, function( index, choice ) {
        $('<input/>', {
            type : 'radio',
            name : 'pass-choice',
            id : 'pass-choice-' + choice,
            value : index,
        }).appendTo($radio_btns);

        $('<label>', {
            for: 'pass-choice-' + choice,
            text: choice
        }).appendTo($radio_btns);
    });

   $radio_btns.appendTo($form).appendTo($config);

   //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        var new_pass = $('input[name=pass-choice]:checked').val();
        if ( entry.pass != new_pass ) {

            scan_ws.send(JSON.stringify( { 
                type: "set_pass",
                freq: entry.freq,
                bank: entry.bank,
                pass: new_pass
            } ));

        }
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);

    $('#pass-choice-'+choices[entry.pass]).attr('checked', true);

    $config.popup("open").trigger("create");

    $('#pass-choice-auto').checkboxradio('disable');
};

scanner_config = function() {

    // approach from: http://stackoverflow.com/questions/16015810/jquery-mobile-best-way-to-create-pop-up-and-content-dynamically

    console.log("squelch: " + scan_config.squelch);
    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : "Scanner Configuration"
    }).appendTo($config);

    //create a form for the pop up
    $('<form>').append(
        $('<label>', {
            for: 'squelch',
            text: 'Squelch'
    }))
    .append($('<input/>', {
        type : 'range',
        name : 'squelch',
        id : 'squelch',
        value : scan_config.squelch,
        min : '0',
        max : '100'
    })).appendTo($config);

   //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        check_for_changes();
        //that.subscribeToAsset(callback);
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);

    $config.popup("open").trigger("create");
};

check_for_changes = function() {

    if ( $('#squelch').val() != scan_config.squelch ) {
        scan_ws.send(JSON.stringify( { type: "set_squelch", squelch: $('#squelch').val() } ));         }

};

