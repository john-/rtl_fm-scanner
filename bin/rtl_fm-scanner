#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use DBIx::Connector;

use constant NO_PASS     => 0;
use constant MANUAL_PASS => 1;
use constant AUTO_PASS   => 2;

# Field positions in DB result set
use constant FREQ       => 0;
use constant DESIGNATOR => 1;
use constant PASS       => 7;

app->plugin('RenderFile');
app->plugin('CORS');        # lets the client get around same origin policy restriction

app->secrets( ['Specfying a secret to make the reminder go away.'] );

my $dbname = '../data/freqs.db';

my $trans_id = 0;
my $xmit_timer;    # stores the id of the loop that limits length of xmit
app->defaults( state => () );

get '/self' => sub {
    my $c    = shift;

    $c->render(json => { function => 'Scanner' } );
};

get '/script' => { template => 'script' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath' => "../archive/$file",
        'content_disposition' => 'inline'
    );
};

get '/freqs' => { template => 'freqs' };

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

# There must be a better way of addressing this.  Requirements are that there is a long running
# process started when aplication starts (see above).  This process needs to exist independently
# of client conntections.  I could not figure out a way for this client specifc code to wait for
# a change in the output from the long running process.  Therefore, it is checking if a global
# that contains current state of that process differs from what was sent to client previously.
# If it does differ it is sent to client.  Otherwise it is ignored.
# In this application there will be at most 2 clients connecting.
    my $trans_ref = 0;
    my $id        = Mojo::IOLoop->recurring(
        0.25 => sub {
            my $loop = shift;

            if ( $trans_ref == $trans_id ) { return }

            my %details = %{ app->defaults('state') };

	    $details{url} = $c->url_for('audio')->to_abs;  # doesn't work in the helper

            $c = $c->send( { json => \%details } );
            app->log->info(
               sprintf( 'let client know about %s', $details{url} ) );
            $trans_ref = $trans_id;
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

            if ( $hash->{type} eq 'pass' ) {
                app->log->info(
                    sprintf( 'Request to put a pass on %s', $hash->{freq} ) );

# TODO:  Update db for this freq and then reload rtl_fm with refreshed list of freqs
                app->update_pass( $hash->{freq}, $hash->{designator} );
                $c->start_rtlfm;
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed with status $code.");
        }
    );
};

helper connector => sub {
    state $db = DBIx::Connector->new( "dbi:SQLite:$dbname", "", "" )
      or app->log->error('Could not connect to database');
};

helper db => sub { shift->connector->dbh };

helper select => sub {
    my ( $self, $group ) = @_;

    # TODO:  At some point limit based on current year or something.
    my $sth = eval {
        $self->db->prepare(
            'SELECT * FROM freqs where groups like ?');
    }
      || return undef;
    $sth->execute($group);
    return $sth->fetchall_arrayref;
};

helper update_pass => sub {
    my ( $self, $freq, $designator ) = @_;
    my $sth = eval {
        $self->db->prepare(
            'UPDATE freqs SET pass=? WHERE frequency = ? AND designator = ?');
    }
      || return undef;
    $sth->execute( AUTO_PASS, $freq, $designator );
};

helper set_state => sub {
    my ( $c, $status, $freq, $file ) = @_;

    # TODO:  Save interesting bits in a DB on open/close

    my $detail;
    if ( $status eq 'OPEN' ) {
        my $freq_list  = app->defaults('freq_list');
        my $designator = $freq_list->{$freq}{designator};
        $detail = {
	    type       => 'audio',
            freq       => $freq,
            file       => $file,
	    #url        => $c->url_for('script')->to_abs,
            trans_id   => $trans_id,
            start      => time(),
            designator => $designator,
        };

        app->defaults( state => $detail );
        app->log->debug( app->dumper($detail) );

	$freq_list->{$freq}{count}++;

        # start timer to stop open mic/long data
        $xmit_timer = Mojo::IOLoop->timer(
            10 => sub {
                my $loop = shift;
                app->update_pass( $freq, $designator );
                app->log->debug(
                    sprintf( 'Set pass on %s (%s)', $freq, $designator ) );
                $c->start_rtlfm;
            }
        );
    }
    else {
        Mojo::IOLoop->remove($xmit_timer);
        $detail = app->defaults('state');
        $detail->{end} = time();
        app->defaults( state => $detail );
        $trans_id++;
    }

};

helper start_rtlfm => sub {
    my $c = shift;

    # errors to handle:
    # dongle yanked:
    #    rtlsdr_demod_write_reg failed with -1
    #    rtlsdr_demod_read_reg failed with -4
    #    cb transfer status: 5, canceling

    if ( defined app->defaults('rtlfm_pid') ) {
        my $pid = app->defaults('rtlfm_pid');
        app->log->info( sprintf( 'About to kill rtl_fm (pid: %s)', $pid ) );
        kill 'HUP', $pid;
        delete app->defaults->{rtlfm_pid};
        Mojo::IOLoop->timer( 1 => sub { $c->start_rtlfm } );   # Time to exit
        return;
    }

    app->log->info('about to start rtl_fm');

    my @freqs = @{ app->select('%FRS%') };

    #app->log->info('database dump'.dumper(@freqs));

    my @freq_args;
    my %freq_list;
    foreach my $freq_detail (@freqs) {
        my $freq = $freq_detail->[FREQ];
        chomp($freq);
        $freq_list{$freq} = { designator => $freq_detail->[DESIGNATOR],
	                      pass       => $freq_detail->[PASS]};

	if ($freq_detail->[PASS] == NO_PASS) {
            push @freq_args, sprintf( "-f %sM", $freq );
        }
    }

    app->defaults( freq_list => \%freq_list );

    #app->log->debug(dumper(app->defaults->{freq_list}));

    my $cmd =
"/usr/local/bin/rtl_fm -M fm -p 34 @freq_args -s 12k -l 80 -g 49.2 -E wav -n ../archive /tmp/ignored.out";

#app->log->info('You must read audio from fifo: aplay -f S16_LE -r 12000 /tmp/rtlfm_audio.wav');

    my $rtlfm_fifo;
    my $rtlfm_pid = open( $rtlfm_fifo, "$cmd 2>&1 |" ) or do {

     # this will not be hit if rtl_fm command is executed and there is no dongle
        app->log->error("Couldn't open rtl_fm: $!");
        return;
    };

    my $stream_in = Mojo::IOLoop::Stream->new($rtlfm_fifo);

    $stream_in = $stream_in->timeout(0);
    $stream_in->on(
        read => sub {
            my ( $stream_in, $bytes ) = @_;
            chomp($bytes);

            # I probably need to seperate OPEN from CLOSED
            if ( $bytes =~ /(OPEN|CLOSED)\|(\d+)\|(.+)/ ) {
                my $status   = $1;
                my $cur_freq = $2 / 1000000;
                my $file     = $3;
                app->set_state( $status, $cur_freq, $file );
                app->log->info(
                    sprintf(
                        'status: %s freq: %s file: %s',
                        $status, $cur_freq, $file
                    )
                );
            }
            elsif ( $bytes =~ /No supported devices found/ ) {
                app->log->error('No dongle connected!');

                # retry in a few seconds
                Mojo::IOLoop->timer( 6 => sub { $c->start_rtlfm } );
                return;
            }
            elsif ( $bytes =~ /Using device/ )
            {    # set pid here as rtl_fm can "open" and fail soon after
                app->defaults( rtlfm_pid => $rtlfm_pid );
            }
            else {
                app->log->info(
                    sprintf( 'not sure what this is: %s', $bytes ) );
            }
        }
    );
    $stream_in->on(
        close => sub {
            my $stream_in = shift;
            app->log->info('stream_in closed');
        }
    );
    $stream_in->on(
        error => sub {
            my ( $stream_in, $err ) = @_;
            app->log->info('stream_in error');
        }
    );
    my $sid = Mojo::IOLoop->stream($stream_in);
    $stream_in->on( finish => sub { Mojo::IOLoop->remove($sid) } );

};

app->start_rtlfm;


app->start;

__DATA__

@@ freqs.html.ep
<!-- TODO:
        - Show indicator for pass (manual), pass (auto), data
        - Allow user to manually override pass or manually set it
        - This is a static page.  Maybe make it update in real time.
-->
<!DOCTYPE html>
<html>
<body>
    <ul data-role="listview" data-inset="false" id="freq_listview">
    % foreach my $freq (sort keys %$freq_list) {
    <li><a href="#"><%= sprintf('%s (%s)', $freq_list->{$freq}{designator}, $freq) %><span class="ui-li-count"><%= $freq_list->{$freq}{count} %></span></a></li>
    % }
    </ul>
</body>
</html>

@@ script.html.ep
console.log("Scanner code running");

var scan_ws = new WebSocket('<%= url_for('output')->to_abs %>');

scan_ws.onmessage = function (event) {
    var msg = JSON && JSON.parse(event.data) || $.parseJSON(data);

    if (msg.type == 'audio') {
        enqueue(msg);
    }
};

scanner_page = function () {

    console.log("Populating scanner page");

    $.ajax({
        url: '<%= url_for('freqs')->to_abs %>',
        cache: false
    })
       .done(function( html ) {
           $( '#scanner' ).empty().append(html).enhanceWithin();
       });
};

