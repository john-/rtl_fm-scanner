#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use DBIx::Connector;

app->plugin('RenderFile');

app->secrets( ['Specfying a secret to make the reminder go away.'] );

my $dbname = '../data/freqs.db';

helper connector => sub {
    state $db = DBIx::Connector->new( "dbi:SQLite:$dbname", "", "" )
      or app->log->error('Could not connect to database');
};

helper db => sub { shift->connector->dbh };

helper select => sub {
    my ( $self, $group ) = @_;
    my $sth =
      eval { $self->db->prepare('SELECT * FROM freqs where groups like ?') }
      || return undef;
    $sth->execute($group);
    return $sth->fetchall_arrayref;
};

helper set_state => sub {
    my ( $c, $status, $freq, $file ) = @_;

    # TODO:  Lookup freq info
    # TODO:  Save interesting bits in a DB
    my $info = 'Static for now';

    my %detail = ( squelch => $status, freq => $freq, info => $info, file => $file, time => time() );
    app->defaults( state => \%detail );
};

helper start_rtlfm => sub {
    my $c = shift;

    # errors to handle:
    # dongle yanked:
    #    rtlsdr_demod_write_reg failed with -1
    #    rtlsdr_demod_read_reg failed with -4
    #    cb transfer status: 5, canceling

    if ( defined app->defaults('rtlfm_pid')) {
	my $pid = app->defaults('rtlfm_pid');
        app->log->info( sprintf( 'About to kill rtl_fm (pid: %s)', $pid ) );
        kill 'HUP', $pid;
	delete app->defaults->{rtlfm_pid};
        Mojo::IOLoop->timer( 1 => sub { $c->start_rtlfm } );  # Killed process needs time to exit
	return;
    }
    
    app->log->info('about to start rtl_fm');

    my @freqs = @{ app->select('%FRS%') };

    #app->log->info('database dump'.dumper(@freqs));

    my @freq_args;
    foreach my $freq_detail (@freqs) {
        my $freq = $freq_detail->[0];
        chomp($freq);
        push @freq_args, sprintf( "-f %sM", $freq );
    }

    my $cmd =
"/usr/local/bin/rtl_fm -M fm -p 34 @freq_args -s 12k -l 80 -g 49.2 -E wav -n ../archive /tmp/ignored.out";

    #app->log->info('You must read audio from fifo: aplay -f S16_LE -r 12000 /tmp/rtlfm_audio.wav');

    my $rtlfm_fifo;
    my $rtlfm_pid = open( $rtlfm_fifo, "$cmd 2>&1 |" ) or do {
     # this will not be hit if rtl_fm command is executed and there is no dongle
        app->log->error(
            "Couldn't open rtl_fm: $!");
        return;
    };

    my $stream_in = Mojo::IOLoop::Stream->new($rtlfm_fifo);

    app->set_state( 'Stopped', 'None', 'None' );
    $stream_in = $stream_in->timeout(0);
    $stream_in->on(
        read => sub {
            my ( $stream_in, $bytes ) = @_;
            chomp($bytes);
	    # I probably need to seperate OPEN from CLOSED
            if ( $bytes =~ /(OPEN|CLOSED)\|(\d+)\|(.+)/ ) {
                my $status   = $1;
                my $cur_freq = $2 / 1000000;
		my $file     = $3;
                app->set_state( $status, $cur_freq, $file );
                app->log->info(
                    sprintf( 'status: %s freq: %s file: %s', $status, $cur_freq, $file ) );
            }
            elsif ( $bytes =~ /No supported devices found/ ) {
                app->log->error('No dongle connected!');

                # retry in a few seconds
                Mojo::IOLoop->timer( 6 => sub { $c->start_rtlfm } );
                return;
            }
	    elsif ( $bytes =~ /Using device/ ) { # set pid here as rtl_fm can "open" and fail soon after
		app->defaults( rtlfm_pid => $rtlfm_pid );
            }
            else {
                app->log->info(
                    sprintf( 'not sure what this is: %s', $bytes ) );
            }
        }
    );
    $stream_in->on(
        close => sub {
            my $stream_in = shift;
            app->log->info('stream_in closed');
        }
    );
    $stream_in->on(
        error => sub {
            my ( $stream_in, $err ) = @_;
            app->log->info('stream_in error');
        }
    );
    my $sid = Mojo::IOLoop->stream($stream_in);
    $stream_in->on( finish => sub { Mojo::IOLoop->remove($sid) } );

};

app->start_rtlfm;

get '/' => { template => 'index' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath' => "../archive/$file",
        #'format'   => 'pdf',                 # will change Content-Type "application/x-download" to "application/pdf"
        'content_disposition' => 'inline',   # will change Content-Disposition from "attachment" to "inline"
	);


    #$c->render(text => "You want $file.");
};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    #app->log->info( 'in websocket: ' . dumper( app->defaults('state') ) );

    # There must be a better way of addressing this.  Requirements are that there is a long running
    # process started when aplication starts (see above).  This process needs to exist independently
    # of client conntections.  I could not figure out a way for this client specifc code to wait for
    # a change in the output from the long running process.  Therefore, it is checking if a global
    # that contains current state of that process differs from what was sent to client previously.
    # If it does differ it is sent to client.  Otherwise it is ignored.
    # In this application there will be at most 2 clients connecting.
    my $prev_time = 0;
    my $id       = Mojo::IOLoop->recurring(
        0.25 => sub {
            my $loop     = shift;
            my %details  = %{ app->defaults('state') };
            my $cur_time = $details{time};

	    if (($details{squelch} eq 'OPEN') || ($prev_time == $cur_time)) { return; };

            $c = $c->send( { json => \%details } );
	    app->log->info( sprintf('let client know about %s', $details{file}) );
            $prev_time = $cur_time;
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

            if ( $hash->{type} eq 'pass' ) {
                app->log->info(
                    sprintf( 'Request to put a pass on %s', $hash->{freq} ) );
		    # TODO:  Update db for this freq and then reload rtl_fm with refreshed list of freqs
		    $c->start_rtlfm;
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed with status $code.");
        }
    );
};

app->start;

__DATA__

@@ index.html.ep
<html>
<head>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.js"></script>
<link rel="stylesheet" href="//ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/themes/smoothness/jquery-ui.css"/>
<script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/jquery-ui.js"></script>
</head>
<body>
<pre id="log"></pre>
<button id="pass">Pass</button>
<div class="ui-widget">
    <input id="tags">
</div>
<audio id="player" controls>
  <source src="<%= url_for('audio')->to_abs %>?file=467637500-20150103065558.audio" type="audio/wav">
Your browser does not support the audio element.
</audio> 

<script>

$(document).ready(function() {


var ws = new WebSocket('<%= url_for('output')->to_abs %>');
var log = document.getElementById('log');
var player = document.getElementById('player');
var chaninfo;
//var clips_list = JSON.parse('{ "clips" : [] }');
var clips = [];
ws.onmessage = function (event) { 
    chaninfo = JSON && JSON.parse(event.data) || $.parseJSON(data);
    clips.push(chaninfo);
    jsonStr2 = JSON.stringify(clips);
    log.innerHTML += JSON.stringify(chaninfo) + "\n";
    //log.innerHTML += chaninfo.file;
    player.src = '<%= url_for('audio')->to_abs %>?file=' + chaninfo.file;
    player.play();
};

//var aud = document.getElementById("player");
player.onended = function() {
    //alert("The audio has ended");
    player.play;
};

var audio = new Audio("<%= url_for('audio')->to_abs %>?file=467637500-20150103065558.audio");
audio.play(); 

// I am not sure what this does except make button bigger
$(function() {
    $( "#pass" ).button();
});

$( "#pass" ).click(function() {
    //alert( "Handler for .click() called." );
    sendText();
});

function sendText() {
  // Construct a msg object containing the data the server needs to process the message from the chat client.
  var msg = {
    type: "pass",
    freq: chaninfo.freq,
    //text: document.getElementById("text").value,
    //id:   clientID,
    date: Date.now()
  };

  // Send the msg object as a JSON-formatted string.
  ws.send(JSON.stringify(msg));
}


$(function() {
    var availableTags = [
        "Item1",
        "Item2",
        "Now3",
        "And4"
    ];
    $( "#tags" ).autocomplete({
        source: availableTags
    });
});
});
</script>

</body>
</html>
