#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use DBIx::Connector;

use constant NO_PASS     => 0;
use constant MANUAL_PASS => 1;
use constant AUTO_PASS   => 2;

# Field positions in DB result set
use constant FREQ       => 0;
use constant DESIGNATOR => 1;
use constant PASS       => 7;

my $config = plugin Config => { file => '../config/scanner.conf' };

app->plugin('RenderFile');
app->plugin('CORS'); # lets the client get around same origin policy restriction

app->secrets( ['Specfying a secret to make the reminder go away.'] );

my $dbname = '../data/freqs.db';

my $xmit_timer;      # stores the id of the loop that limits length of xmit
app->defaults( state => () );

get '/self' => sub {
    my $c = shift;

    $c->render( json => { function => 'Scanner' } );
# ugh this is nasty but I need to store it here because it does not work in the helper
    app->defaults->{audio_url} = $c->url_for('audio')->to_abs;
};

get '/script' => { template => 'script' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath'            => "../archive/$file",
        'content_disposition' => 'inline'
    );
};

get '/freqs' => sub {
    my $c = shift;

    $c->render( json => app->defaults('freq_list') );
};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    my $client =
      $c->tx->remote_address . $c->tx->remote_port;    # unique identifier

    $c->send( { json => app->config_msg } );

    my $id        = Mojo::IOLoop->recurring(
        0.5 => sub {
            my $loop = shift;

	    while ( my $msg = app->get_msg($client) )
            {
                $c = $c->send( { json => $msg } );
                app->log->info("item to let client know about: $msg->{type}");
            }
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

	    if ( $hash->{type} eq 'ping' ) {
		app->log->debug('client pinged me');
            } elsif ( $hash->{type} eq 'set_pass' ) {
                app->log->info(
                    sprintf( 'Request to change pass for %s to %s', $hash->{freq}, $hash->{pass} ) );

                app->update_pass( $hash->{freq}, $hash->{designator}, $hash->{pass} );
                $c->start_rtlfm;
            }
            elsif ( $hash->{type} eq 'set_squelch' ) {
                $config->{squelch} = $hash->{squelch};
                $c->start_rtlfm;    # need to start rtl_fm for changes to take effect

		app->publish( app->config_msg );
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed with status $code.");
        }
    );
};

helper get_msg => sub {
    my ( $self, $client ) = @_;

    return shift @{ app->defaults->{announce_sub}{$client} };
};

helper publish => sub {
    my ( $self, $msg ) = @_;

    push @$_, $msg
      for values %{ app->defaults->{announce_sub} };
};

helper config_msg => sub {
    my $self = shift;

    return { type => 'config', %{ $config } };
};


helper connector => sub {
    state $db = DBIx::Connector->new( "dbi:SQLite:$dbname", "", "" )
      or app->log->error('Could not connect to database');
};

helper db => sub { shift->connector->dbh };

helper select => sub {
    my ( $self, $group ) = @_;

    # TODO:  At some point limit based on current year or something.
    my $sth =
      eval { $self->db->prepare('SELECT * FROM freqs where groups like ?'); }
      || return undef;
    $sth->execute($group);
    return $sth->fetchall_arrayref;
};

helper update_pass => sub {
    my ( $self, $freq, $designator, $pass ) = @_;
    my $sth = eval {
        $self->db->prepare(
            'UPDATE freqs SET pass=? WHERE frequency = ? AND designator = ?');
    }
      || return undef;
    $sth->execute( $pass, $freq, $designator );
    #app->log->info( sprintf('|%s|%s|%s|', $pass, $freq, $designator) );
};

helper set_state => sub {
    my ( $c, $status, $freq, $file ) = @_;

    # TODO:  Save interesting bits in a DB on open/close

    my $detail;
    if ( $status eq 'OPEN' ) {
        my $freq_list  = app->defaults('freq_list');
        my $designator = $freq_list->{$freq}{designator};
        $detail = {
            type       => 'audio',
            freq       => $freq,
            file       => $file,
	    count      => ++$freq_list->{$freq}{count},
            url        => app->defaults->{audio_url},
            start      => time(),
            designator => $designator,
        };

        app->defaults( state => $detail );
        #app->log->debug( app->dumper($detail) );

        # start timer to stop open mic/long data
        $xmit_timer = Mojo::IOLoop->timer(
            10 => sub {
                my $loop = shift;
                app->update_pass( $freq, $designator, AUTO_PASS );
                app->log->debug(
                    sprintf( 'Set pass on %s (%s)', $freq, $designator ) );
                $c->start_rtlfm;
            }
        );
    }
    else {
        Mojo::IOLoop->remove($xmit_timer);
        $detail = app->defaults('state');
        $detail->{end} = time();
        app->defaults( state => $detail );
	app->publish( $detail );
    }

};

helper start_rtlfm => sub {
    my $c = shift;

    # errors to handle:
    # dongle yanked:
    #    rtlsdr_demod_write_reg failed with -1
    #    rtlsdr_demod_read_reg failed with -4
    #    cb transfer status: 5, canceling

    if ( defined app->defaults('rtlfm_pid') ) {
        my $pid = app->defaults('rtlfm_pid');
        app->log->info( sprintf( 'About to kill rtl_fm (pid: %s)', $pid ) );
        kill 'HUP', $pid;
        delete app->defaults->{rtlfm_pid};
        Mojo::IOLoop->timer( 1 => sub { $c->start_rtlfm } );    # Time to exit
        return;
    }

    app->log->info('about to start rtl_fm');

    my @freqs = @{ app->select( $config->{group} ) };

    app->publish( { type => 'update' } );  # if start of rtl_fm expect change
    #app->log->info('database dump'.dumper(@freqs));

    my @freq_args;
    my %freq_list;
    foreach my $freq_detail (@freqs) {
        my $freq = $freq_detail->[FREQ] += 0;  # remove trailing zeros
        chomp($freq);
        $freq_list{$freq} = {
            designator => $freq_detail->[DESIGNATOR],
            pass       => $freq_detail->[PASS]
        };

        if ( $freq_detail->[PASS] == NO_PASS ) {
            push @freq_args, sprintf( "-f %sM", $freq );
        }
    }

    app->defaults( freq_list => \%freq_list );

    #app->log->debug(dumper(app->defaults->{freq_list}));

    my @args = ( '/usr/local/bin/rtl_fm',
		 '-M', $config->{mode},
		 '-p', $config->{ppm},
		 '-s', '12k',
		 '-l', $config->{squelch},
		 '-g', $config->{gain},
		 '-E', 'wav',
		 @freq_args,
		 '-n', '../archive',
		 '/tmp/ignored.out'
	);
    my $cmd = join(' ', @args);

    my $rtlfm_fifo;
    my $rtlfm_pid = open( $rtlfm_fifo, "$cmd 2>&1 |" ) or do {

     # this will not be hit if rtl_fm command is executed and there is no dongle
        app->log->error("Couldn't open rtl_fm: $!");
        return;
    };

    my $stream_in = Mojo::IOLoop::Stream->new($rtlfm_fifo);

    $stream_in = $stream_in->timeout(0);
    $stream_in->on(
        read => sub {
            my ( $stream_in, $bytes ) = @_;
            chomp($bytes);

            # I probably need to seperate OPEN from CLOSED
            if ( $bytes =~ /(OPEN|CLOSED)\|(\d+)\|(.+)/ ) {
                my $status   = $1;
                my $cur_freq = $2 / 1000000;
                my $file     = $3;
                app->set_state( $status, $cur_freq, $file );
                app->log->info(
                    sprintf(
                        'status: %s freq: %s file: %s',
                        $status, $cur_freq, $file
                    )
                );
            }
            elsif ( $bytes =~ /No supported devices found/ ) {
                app->log->error('No dongle connected!');

                # retry in a few seconds
                Mojo::IOLoop->timer( 6 => sub { $c->start_rtlfm } );
                return;
            }
            elsif ( $bytes =~ /Using device/ )
            {    # set pid here as rtl_fm can "open" and fail soon after
                app->defaults( rtlfm_pid => $rtlfm_pid );
            }
            else {
                app->log->info(
                    sprintf( 'not sure what this is: %s', $bytes ) );
            }
        }
    );
    $stream_in->on(
        close => sub {
            my $stream_in = shift;
            app->log->info('stream_in closed');
        }
    );
    $stream_in->on(
        error => sub {
            my ( $stream_in, $err ) = @_;
            app->log->info('stream_in error');
        }
    );
    my $sid = Mojo::IOLoop->stream($stream_in);
    $stream_in->on( finish => sub { Mojo::IOLoop->remove($sid) } );

};

app->start_rtlfm;

app->start;

__DATA__

@@ script.html.ep
console.log("Scanner code running");

var scan_ws = new WebSocket('<%= url_for('output')->to_abs %>');

setInterval(function () {
        scan_ws.send(JSON.stringify( { type: "ping" } ));
        }, 45000
);

var scan_config;
scan_ws.onmessage = function (event) {
    var msg = $.parseJSON(event.data);

    switch (msg.type) {
        case 'audio':
            enqueue(msg);
            scanner_page();
            break;
        case 'update':
            scanner_page();
            break;
        case 'config':
            scan_config = msg;
            break;
    }
};

scanner_page = function () {

    // TODO: this is pretty convoluted and better way should be found
    var active_id = $("#switcher").tabs("option", "active");
    active = $("#switcher ul>li a").eq(active_id).attr('href');

    if (active != '#scanner') { return }

    console.log("Populating scanner page");

    $.getJSON( '<%= url_for('freqs')->to_abs %>' )
        .done(function( json ) {
   	    $('#scanner').empty().append('<ul data-role="listview" id="frequencies"></ol>');
	    $.each( json, function(freq, detail) {

                var info = freq.toString();
                if (detail.count) { info += ' / ' + detail.count + ' hits' }
                switch (detail.pass) {
                    case 1:
                        info += ' / Manual Pass';
                        break;
                    case 2:
                        info += ' / Auto Pass';
                        break;
                }
                var contents = '<h2>' + detail.designator + '</h2><p>' + 
                               info + '</p>';

		$('<li/>')
		    .append(
		  	$('<a/>', {
			    html: contents,
			    href: "#" + freq,
                            id: freq
			})
			).appendTo("#frequencies");

            });  // end .each

            // There may be another way but this appears to work:
            // http://www.gajotres.net/uncaught-error-cannot-call-methods-on-prior-to-initialization-attempted-to-call-method-refresh/
            $('#frequencies').listview().listview('refresh');

            $( '#frequencies li a' ).on( "taphold", function( event ) {
                var freq = $( this ).attr('id');
                frequency_config(freq, json[freq]);
            });

        });  // end .done


};

frequency_config = function(freq, detail) {

    var choices = [ 'none', 'manual', 'auto' ];

    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : detail.designator + '(' + freq + ')'
    }).appendTo($config);

    //create a form for the pop up
    var $form = $('<form/>');

    var $radio_btns = $('<fieldset/>', {
            'data-role': 'controlgroup',
            'data-type': 'horizontal'
        });

    $('<legend/>', { text: 'Pass' }).appendTo($radio_btns);

    $.each( choices, function( index, choice ) {
        $('<input/>', {
            type : 'radio',
            name : 'pass-choice',
            id : 'pass-choice-' + choice,
            value : index,
        }).appendTo($radio_btns);

        $('<label>', {
            for: 'pass-choice-' + choice,
            text: choice
        }).appendTo($radio_btns);
    });

   $radio_btns.appendTo($form).appendTo($config);

   //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        var new_pass = $('input[name=pass-choice]:checked').val();
        if ( detail.pass != new_pass ) {

            scan_ws.send(JSON.stringify( { 
                type: "set_pass",
                freq: freq,
                designator: detail.designator,
                pass: new_pass
            } ));

        }
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);

    $('#pass-choice-'+choices[detail.pass]).attr('checked', true);

    $config.popup("open").trigger("create");

    $('#pass-choice-auto').checkboxradio('disable');
};

scanner_config = function() {

    // approach from: http://stackoverflow.com/questions/16015810/jquery-mobile-best-way-to-create-pop-up-and-content-dynamically

    console.log("squelch: " + scan_config.squelch);
    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : "Scanner Configuration"
    }).appendTo($config);

    //create a form for the pop up
    $('<form>').append(
        $('<label>', {
            for: 'squelch',
            text: 'Squelch'
    }))
    .append($('<input/>', {
        type : 'range',
        name : 'squelch',
        id : 'squelch',
        value : scan_config.squelch,
        min : '0',
        max : '100'
    })).appendTo($config);

   //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        check_for_changes();
        //that.subscribeToAsset(callback);
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);

    $config.popup("open").trigger("create");
};

check_for_changes = function() {

    if ( $('#squelch').val() != scan_config.squelch ) {
        scan_ws.send(JSON.stringify( { type: "set_squelch", squelch: $('#squelch').val() } ));         }

};

